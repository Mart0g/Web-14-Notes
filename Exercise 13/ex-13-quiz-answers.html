<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 9 - Answers</title>
  </head>
  <body>
		<h1>Kahoot! Quiz Отговори - JS-2</h1>
		<ol>
			<li>
				<h3>Всичко в JavaScript e:</h3>
				<ul>
					<li><strong><em>Примитивен тип или обект</em></strong></li>
					<li>Функция или обект</li>
					<li>Само обект</li>
					<li>Число или обект</li>
				</ul>
				<p><strong>Защо?:</strong> Примитивните типове са null, undefined, boolean, number, string и т.н. - те нямат свойства или методи. Всичко останало може да се приема като обект, който обикновено е wrap-нат в някой от примитивните типове имплицитно.</p>
			</li>
			<li>
				<h3>Какъв е функционалният scope на променливи от тип var във функция с if-условия в JS?</h3>
				<ul>
					<li>Глобален (Global Scope)</li>
					<li><strong><em>Локален - самата функция (Function Scope)</em></strong></li>
					<li>Блоков - заради if блока (Block Scope)</li>
					<li>Нямат собствен такъв (No Scope)</li>
				</ul>
				<p><strong>Защо?:</strong> var променливите, дефинирани вътре във функция, са достъпни само за самата функция, т.е. имат function scope. Преди ES6, конструкции като if нямат собствен scope, което означава, че block scope можем да постигнем ако използваме let, а не var (т.е. втората е налична за цялата функция, не само в if условието).</p>
      </li>
      <li>
				<h3>Чрез кой от следните JS методи НЕ можем да променим стойността на this обекта?</h3>
				<ul>
					<li>call</li>
					<li>apply</li>
					<li><strong><em>assign</em></strong></li>
					<li>bind</li>
				</ul>
				<p><strong>Защо?:</strong> call и apply са почти идентични, разликата е в начина, по който приемат аргументите си. bind връща нов метод, чийто първи подаден аргумент е новата стойност на this. Вградена функция assign няма в JS (освен ако не говорим за Object.assign(), но това няма нищо общо с this).</p>
			</li>
			<li>
				<h3>Design patterns ни спестяват дефинирането на твърде много глобални променливи и функции.</h3>
				<ul>
					<li><strong><em>Вярно</em></strong></li>
					<li>Грешно</li>
				</ul>
				<p><strong>Защо?:</strong> Всъщност точно това им е идеята - накратко казано, да преизползваме някаква логика, която често решава определени проблеми, вместо да се налага да си я дефинираме отново всеки път.</p>
			</li>
			<li>
				<h3>Какво ще върне следното в JS?: [...'Martin'];</h3>
				<ul>
					<li>["Martin"]</li>
					<li>[[], "Martin"]</li>
					<li>[["M", "a", "r", "t", "i", "n"]]</li>
					<li><strong><em>["M", "a", "r", "t", "i", "n"]</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> Стринговете са итерируеми (iterable) и могат и да се разглеждат като масив от символи. Това означава, че spread оператора свързва всеки символ от итерируемия елемент с елемент и съответно връща масив от елементите.</p>
			</li>
			<li>
				<h3>Какво ще се логне?: fetch('http://url.bg/1').then(res => res.json()).then(res => console.log(res));</h3>
				<ul>
					<li>Резултатът от fetch() метода.</li>
					<li>Резултатът от второто извикване на fetch (т.е. втория .then()).</li>
					<li><strong><em>Резултатът от callback-а в предишния .then() (т.е. първия).</em></strong></li>
					<li>Резултатът винаги ще е undefined.</li>
				</ul>
				<p><strong>Защо?:</strong> Стойността на res във втория then е същата като тази, която е била върната в предишния .then(). Можем да добавяме още .then() извиквания (chaining), където стойността просто ще се предава на следващото извикване (handler).</p>
			</li>
			<li>
				<h3>Какъв ще е резултатът от следното в JS?: Promise.resolve(42);</h3>
				<ul>
					<li>42</li>
					<li>Promise {&lt;pending&gt;: 42}</li>
					<li><strong><em>Promise {&lt;resolved&gt;: 42}</em></strong></li>
					<li>Error</li>
				</ul>
				<p><strong>Защо?:</strong> Можем да подадем каквато и да е стойност на promise. Самият метод отново връща promise с успешно изпълнената/върнатата от него стойност (resolved). Ако подадем обикновена функция, ще получим изпълнен promise с получената от функция стойност. Ако подадем друг promise, отново ще получим изпълнен promise с върнатата стойност от успешно изпълнения подаден promise.</p>
			</li>
			<li>
				<h3>Какво ще се изведе в конзолата?: function sum(a, b = a) { console.log(a + b); }; sum(5);</h3>
				<ul>
					<li>NaN</li>
					<li><strong><em>10</em></strong></li>
					<li>5</li>
					<li>undefined</li>
				</ul>
				<p><strong>Защо?:</strong> Можем да задаваме стойността на даден параметър по подразбиране да е равна на стойността на друг параметър, но за да е възможно това, трябва другият параметър да е дефиниран преди този, на който задаваме стойност по подразбиране. В случая условието е изпълнено и тъй като не подаваме при извикването на функцията стойност на b, то b взима стойността си по подразбиране, която е равна на тази на a. Ако се опитаме да зададем стойност по същия начин, но променливата, която използваме, е дефинирана след тази, на която искаме да зададем стойност по подразбиране, JS ще ни върне грешка.</p>
			</li>
			<li>
				<h3>NodeJS е framework, подобен на ReactJS и AngularJS.</h3>
				<ul>
					<li>Вярно</li>
					<li><strong><em>Грешно</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> NodeJS е среда, която се използва за изпълнение на сървърни или мрежови приложения, написани на JS (т.е. играе ролята на сървър). Останалите две са frameworks, които се използват за писане на frontend JS.</p>
			</li>
			<li>
				<h3>Как се нарича скрипт, генериращ код с по-стар синтаксис на базата на по-нов такъв, с цел поддръжка на стари браузъри?</h3>
				<ul>
					<li>compiler</li>
					<li>translator</li>
					<li>transformer</li>
					<li><strong><em>transpiler</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> Transpiler реално е комбинация от думите translator и compiler и прави точно това, което е зададено в условието на въпроса. Пример за такъв скрипт в JS е babel.</p>
			</li>
		</ol>
  </body>
</html>