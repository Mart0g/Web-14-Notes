<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 4 - Answers</title>
  </head>
  <body>
		<h1>Kahoot! Quiz Отговори - JS</h1>
		<ol>
			<li>
				<h3>В JavaScript: "1,2,3" == [1,2,3] ?</h3>
				<ul>
					<li><strong><em>Вярно</em></strong></li>
          <li>Грешно</li>
				</ul>
				<p><strong>Защо?:</strong> В случая имаме обикновено равенство, откъдето следва, че JS ще конвертира всичко в стринг (т.е. и масивът ще бъде конвертиран в стринг) преди да сравни стойностите и резултат ще е верен. Ако имаме стриктно равенство обаче (===), вече ще ги сравни и по тип без да ги преобразува и резултатът ще е false.</p>
			</li>
			<li>
				<h3>Какво ще се изведе в конзолата: console.log(!!""); ?</h3>
				<ul>
					<li>null</li>
          <li>undefined</li>
          <li>true</li>
					<li><strong><em>false</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> Операторът за двойно отрицание е по-модерен начин за превръщане на не-булева стойност в булева. В случая вариантите ни са само последните две, но тъй като празният стринг се приема за falsy стойност, то отговорът остава да е false.</p>
			</li>
			<li>
				<h3>Кое от изброените НЕ е характеристика на first-class функциите в JS?</h3>
				<ul>
					<li>Могат да се съхраняват в променлива.</li>
          <li>Могат да бъдат подадени като аргумент на друга функция.</li>
          <li>Могат да бъдат съхранени като част от структура от данни (например обект).</li>
					<li><strong><em>Всички изброени са характеристики на тези функции.</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> Всички изброени са неща, специфични за first-class функциите. Освен това те могат да бъдат върнати като резултат от други функции, както и да имат собствени променливи и методи.</p>
			</li>
			<li>
				<h3>Нека имаме дефиниран обект Car(year, horsePower, maxSpeed). Тогава можем да добавим ново property Car.brand = "VW Golf".</h3>
				<ul>
					<li>Вярно</li>
          <li><strong><em>Грешно</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> В JS не можем да добавяме по този начин нови properties (не можем директно да променяме конструктората на обекта). За да го направим, трябва да променим прототипа на обекта, т.е. в случая искаме следното: <strong>Car.prototype.brand = "VW Golf"</strong>. Добре е и да знаем, че е препоръчително да променяме properties само на обекти, създадени от нас, а не на стандартните JS такива.</p>
			</li>
			<li>
				<h3>Кой от следните начини за JS селектиране НЯМА да върне всички елементи от типа: &lt;p class="paragraph"&gt;&lt;/p&gt; ?</h3>
				<ul>
					<li><strong><em>document.querySelector('.paragraph');</em></strong></li>
          <li>document.getElementsByTagName('p');</li>
          <li>document.querySelectorAll('.paragraph')</li>
					<li>document.getElementsByClassName('paragraph');</li>
				</ul>
				<p><strong>Защо?:</strong> querySelector връща само първия резултат, който отговаря на условието (класа на елемента).</p>
			</li>
			<li>
				<h3>Кой от глобалните JS обекти има share метод, който имитира native share-а при мобилни устройства?</h3>
				<ul>
					<li>document</li>
          <li><strong><em>navigator</em></strong></li>
          <li>screen</li>
					<li>window</li>
				</ul>
				<p><strong>Защо?:</strong> От известно време насам съществува т.нар. WebShare API, което симулира native share-а и при браузъри. Споделянето на текст и URL-и вече може да бъде постигнато чрез navigator.share функцията. От известно време се поддържа и споделяне на файлове, но за момента само за Chrome for Android.</p>
			</li>
			<li>
				<h3>Какво ще върне следното: typeof NaN ?</h3>
				<ul>
					<li>string</li>
          <li>boolean</li>
          <li><strong><em>number</em></strong></li>
					<li>undefined</li>
				</ul>
				<p><strong>Защо?:</strong> Колкото и странно и нелогично да звучи, ECMAScript спецификацията казва, че Number типът съдържа в себе си и NaN (Not-A-Number). Това е само едно от стотици подобни явления, с които ще се сблъскате в JS. :)</p>
			</li>
			<li>
				<h3>Какъв ще е резултатът от следната операция: 1+2+"3" ?</h3>
				<ul>
					<li>6</li>
          <li>"6"</li>
          <li>33</li>
					<li><strong><em>"33"</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> JS ще се погрижи да събере първите две числа, но след като види, че при втората операция едната стойност е от тип number, а другата от тип string, то няма да извърши аритметичната операция събиране, а операцията конкатенация и в крайна сметка резултатът ще е стринг със стойност "33".</p>
			</li>
			<li>
				<h3>Как се нарича в JS използването на функции и променливи преди въобще да са били декларирани?</h3>
				<ul>
					<li>bubbling</li>
          <li>capturing</li>
          <li><strong><em>hoisting</em></strong>></li>
					<li>handling</li>
				</ul>
				<p><strong>Защо?:</strong> Bubbling е процесът, при който настъпило събитие се изпълнява първо върху даден елемент, след това върху родителския му и така нагоре по DOM дървото до достигане на кореновия. Capturing е обратният процес - събитието се изпълнява първо върху кореновия елемент и след това тръгва надолу по дървото до достигане на целевия такъв. Handling е написано за объркване, може да се разгледа като event handling или т.е. обработката на всякакви събития, настъпили в браузъра поради някакво действие - например click от потребителя. Съответно остава hoisting, което е точно това (т.е. можем да напишем например <strong>a=5;</strong> още в началото на файла си и чак на по-късен етап да го декларираме с <strong>var a;</strong>).</p>
			</li>
			<li>
				<h3>Кой от следните популярни JS frameworks е backend ориентиран?</h3>
				<ul>
					<li>Angular</li>
          <li><strong><em>Express</em></strong></li>
          <li>Vue</li>
					<li>React</li>
				</ul>
				<p><strong>Защо?:</strong> Express e базиран на Node.js, която е една от най-популярните среди за изпълнение на JS код извън браузъра в последно време. Останалите изброени също са изключително нашумели и често използвани, но се използват основно за frontend.</p>
			</li>
		</ol>
  </body>
</html>