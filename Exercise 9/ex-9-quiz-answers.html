<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 6 - Answers</title>
  </head>
  <body>
		<h1>Kahoot! Quiz Отговори - MySQL</h1>
		<ol>
			<li>
				<h3>Кой от следните типове JOIN връща само записите, съдържащи се и в двете бази данни?</h3>
				<ul>
					<li>FULL JOIN</li>
          <li><strong><em>INNER JOIN</em></strong></li>
          <li>LEFT JOIN</li>
          <li>RIGHT JOIN</li>
				</ul>
				<p><strong>Защо?:</strong> Всички са валидни начини за взимане на записи, но се използват различно в зависимост от това от коя таблица какви данни искаме да вземем. INNER JOIN е това, което използваме, ако искаме да вземем всички редове/записи/кортежи, които отговарят на зададеното условие и се съдържат и в двете бази данн.</p>
      </li>
			<li>
				<h3>В phpMyAdmin можем да пишем директно SQL заявки и сами без да имаме нужда от UI.</h3>
				<ul>
					<li><strong><em>Вярно</em></strong></li>
          <li>Грешно</li>
				</ul>
				<p><strong>Защо?:</strong> phpMyAdmin предоставя UI за работа с бази данни, но това не означава, че не можем и сами да си направим заявките, пишейки ги в SQL секцията, която панелът предоставя.</p>
			</li>
      <li>
				<h3>Кой е препоръчаният начин за свързване към SQL от PHP?</h3>
				<ul>
					<li>mysql</li>
          <li>mysqli</li>
          <li><strong><em>PDO</em></strong></li>
          <li>Никое от изброените</li>
				</ul>
				<p><strong>Защо?:</strong> <strong>mysql</strong> е най-старият начин, който вече е deprecated. <strong>mysqli</strong> е по-модерната версия, която е и обектно-ориентирана. Въпреки това, <strong>PDO</strong> е може би най-удобният начин, тъй като предоставя абстрактен интерфейс, който ще работи дори и при смяна на базата данни и engine-ът зад нея.</p>
			</li>
			<li>
				<h3>Можем да управляваме грешки от заявки към базата чрез четвъртия параметър при създаване на нова инстанция на PDO класа.</h3>
				<ul>
					<li><strong><em>Вярно</em></strong></li>
          <li>Грешно</li>
				</ul>
				<p><strong>Защо?:</strong> Четвъртият параметър при създаване на инстанция на класа PDO е опционален, но дефиницията му позволява да задаваме допълнителни атрибути, които биха ни били полезни. Така например можем да зададем PDO::ATTR_ERRMODE, което е препоръчително, за да хванем евентуални грешки при изпълнение на заявките, както и например PDO::ERRMODE_EXCEPTION, което ще накара PDO да хвърля exception при всяка подобна грешка, без да се налага ние сами да я прихващаме. Това означава, че ни е достатъчно да ползваме обикновен try/catch блок, за да сме сигурни, че няма да изпуснем нещо непредвидено.</p>
			</li>
      <li>
				<h3>Как се наричат заявките, които могат да се подготвят предварително преди да бъдат изпълнени?</h3>
				<ul>
					<li>queries</li>
          <li>prepared queries</li>
          <li>statements</li>
          <li><strong><em>prepared statements</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> Prepared statements позволяват заявката да се подготви предварително и да бъде изпълнена на по-късен етап, давайки повече сигурност и по-голяма скорост на изпълнението ѝ.</p>
      </li>
      <li>
				<h3>Кой от следните методи за извличане на данни от базата връща всички резултати под формата на масив?</h3>
				<ul>
					<li>fetch</li>
          <li>fetchColumn</li>
          <li><strong><em>fetchAll</em></strong></li>
          <li>fetchArray</li>
				</ul>
				<p><strong>Защо?:</strong> <strong>fetch</strong> връща само един ред/запис/кортеж от базата, <strong>fetchColumn</strong>> - само една колона от този ред/запис/кортеж, а <strong>fetchArray</strong>> просто не съществува (има само <strong>fetchObject</strong>). <strong>fetchAll</strong> е методът, който връща всички резултати, отговарящи на заявката, под формата на масив.</p>
      </li>
      <li>
				<h3>Ако искаме да върнем данните от базата като анонимен обект чрез PDO, трябва да използваме PDO::FETCH_ASSOC.</h3>
				<ul>
					<li>Вярно</li>
          <li><strong><em>Грешно</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> PDO::FETCH_ASSOC връща данните под формата на асоциативен масив, където ключовете са имената на колоните. PDO:FETCH_OBJ е това, което отново ще ни върне колоните като ключове, но този път в обект.</p>
			</li>
			<li>
				<h3>За изпълнение на подготвена заявка $stmt в PHP се използва $stmt->$query().</h3>
				<ul>
					<li>Вярно</li>
          <li><strong><em>Грешно</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> PHP методът за изпълнение на подобна заявка (prepared statement) е execute().</p>
      </li>
      <li>
				<h3>Кое от следните позволява промяна на изпратената в заявката стойност дори и след bind (но преди execute)?</h3>
				<ul>
					<li>bindColumn</li>
          <li><strong><em>bindParam</em></strong></li>
          <li>bindValue</li>
          <li>Никое от изброените</li>
				</ul>
				<p><strong>Защо?:</strong> bindParam извършва bind на даден placeholder от заявката с променлива, но ако след подготвянето на заявката стойността на променливата се промени, то новата стойност ще бъде използвана и при изпълнение на заявката (за разлика от bindValue, където ще се използва стойността, зададена при извършване на самия bind).</p>
      </li>
      <li>
				<h3>По кой от следните начини можем да подадем желана от нас стойност в заявка чрез PHP?</h3>
				<ul>
					<li>Чрез подаване на обикновен масив при извикване на метода execute().</li>
          <li>Чрез подаване на асоциативен масив при извикване на метода execute().</li>
          <li>Чрез използване на bindParam/bindValue преди извикване на метода execute().</li>
          <li><strong><em>Всички изброени могат да бъдат използвани.</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> Различните програмисти могат да решат да използват различни подходи за подаване на необходимите за заявката данни. Първите две се използват по-често и са по-практични в сравнение с третото, но и тези функции все още се използват в доста проекти.</p>
      </li>
		</ol>
  </body>
</html>