<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 2 - Answers</title>
  </head>
  <body>
		<h1>Kahoot! Quiz Отговори - PHP</h1>
		<ol>
			<li>
				<h3>В кой от редовете са изброени само валидни стойности (като част от двойка ключ-стойност) в асоциативен масив в PHP?</h3>
				<ul>
					<li>0, 1, 2, 3</li>
          <li>"Gosho", "Pesho", "Tosho", "Sasho"</li>
          <li>"answer", "is", 42, array(true, false, true)</li>
					<li><strong><em>Всички изброени</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> При използване на асоциативен (не обикновен индексиран) масив нямаме ограничение за това какъв тип е стойността, която съхраняваме. Можем спокойно да имаме и разнородни ключове, които сочат към стойности от различен тип.</p>
			</li>
			<li>
				<h3>Кое от следните НЕ е глобална променлива в PHP?</h3>
				<ul>
					<li>$_SERVER</li>
					<li><strong><em>$_STORAGE</em></strong></li>
					<li>$_SESSION</li>
					<li>$_COOKIE</li>
				</ul>
				<p><strong>Защо?:</strong> Подобни променливи се наричат "superglobals". $_STORAGE не съществува, другите се използват за съхраняване и достъп до различен тип информация, обикновено специфична за потребителя.</p>
			</li>
			<li>
				<h3>&lt;? echo "Am I valid"; ?&gt; е валиден PHP синтаксис.</h3>
				<ul>
					<li><strong><em>Вярно</em></strong></li>
          <li>Грешно</li>
				</ul>
				<p><strong>Защо?:</strong> <strong>&lt;? echo "Hi!"; ?&gt;</strong> е валиден точно колкото и <strong>&lt;?php echo "Hi!"; ?&gt;</strong>. Единственото специфично е, че в нашия <strong>php.ini</strong> файл трябва изрично да зададем <strong>short_open_tag = On</strong>, за да можем да използваме краткия синтаксис.</p>
			</li>
			<li>
				<h3>Каква е командата за стартиране на сесия в PHP?</h3>
				<ul>
					<li>start_session()</li>
					<li>session_init()</li>
					<li><strong><em>session_start()</em></strong></li>
					<li>session()</li>
				</ul>
				<p><strong>Защо?:</strong> Честно казано, тук няма какво особено да се каже. В PHP това е начинът за създаване на нова сесия или продължаване на съществуваща такава.</p>
			</li>
			<li>
				<h3>Възможно ли е ръчно да изтрием cookie (бисквитка) с помощта на PHP?</h3>
				<ul>
					<li>Да, като извикаме метода unset().</li>
          <li>Не, защото нямаме такава вградена функция.</li>
          <li>Да, като го изтрием през Application таб-а на браузъра ни.</li>
					<li><strong><em>Да, като извикаме метода setcookie(), но с време на изтичане в миналото.</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> В PHP няма готов метод, който да се грижи за триенето на кукита. Това може да стане и през браузъра като ръчно го изтрием от Application таб-а ни за съответния сайт. През PHP обаче начинът е чрез "създаване" на ново куки със същото име, но с време на изтичане дори и няколко секунди по-малко (по-рано) от текущия момент (т.е. в миналото).</p>
			</li>
			<li>
				<h3>Резултат? - function love($person, $lang = "PHP") { return "$person loves $lang.\n"; } echo love("Marto");</h3>
				<ul>
					<li><strong><em>"Marto loves PHP."</em></strong></li>
					<li>"Marto loves ."</li>
					<li>" loves PHP."</li>
					<li>"Marto loves null."</li>
				</ul>
				<p><strong>Защо?:</strong> Ако при дефиницията на функция зададем стойност на някоя от променливите, тя става default. Съответно при извикването на функция, в случай, че не сме подали стойност за параметъра, ще се използва стойността му по default. Ако не искаме тя да се вижда, може просто да я зададем като null (например ако искаме да избегнем показването на първия параметър на страницата, в случая - love(null) или просто love()).</p>
			</li>
			<li>
				<h3>Коя функция бихте използвали за дефинирането на конструктор на класа MyAwesomeClass?</h3>
				<ul>
					<li>MyAwesomeClass()</li>
					<li>__constructor()</li>
					<li><strong><em>__construct()</em></strong></li>
					<li>construct()</li>
				</ul>
				<p><strong>Защо?:</strong> В старите версии конструктор може да бъде създаден и използвайки като ключова дума самото име на класа. С навлизането на PHP 7 обаче това вече се смята за deprecated и не е препоръчително да се ползва при писането на нов код. Останалите две просто не съществуват.</p>
			</li>
			<li>
				<h3>Кой е правилният начин за наследяване на клас в PHP?</h3>
				<ul>
					<li>class Question inherits Quiz</li>
					<li><strong><em>class Question extends Quiz</em></strong></li>
					<li>class Question : Quiz</li>
					<li>class Question(Quiz)</li>
				</ul>
				<p><strong>Защо?:</strong> Първият вариант не се използва никъде, а останалите два са начина за наследяване съотвено при езиците C# и Python. Java е аналогично на PHP и затова го няма в отговорите. :)</p>
			</li>
			<li>
				<h3>В PHP можем да дефинираме следното: class Lion extends Cat, Animal.</h3>
				<ul>
					<li>Вярно</li>
					<li><strong><em>Грешно</em></strong></li>
				</ul>
				<p><strong>Защо?:</strong> PHP не поддържа множествено наследяване, т.е. един клас може да има само един клас за родител. Технически погледнато обаче, в новите версии на PHP все пак има workaround, който може да разгледате при по-голям интерес - <strong>traits</strong>.</p>
			</li>
			<li>
				<h3>Коя вградена PHP функция бихте използвали, за да превърнете string в масив (но НЕ от единични символи/chars)?</h3>
				<ul>
					<li><strong><em>explode()</em></strong></li>
					<li>parse_str()</li>
					<li>implode()</li>
					<li>str_split()</li>
				</ul>
				<p><strong>Защо?:</strong> explode() е най-често използваният метод за подобна операция. str_split() също превръща стринговете в масиви, но от единични символи. implode() прави точно обратното - обединява елементите на масив в един стринг. parse_str() се използва за дефинирането на параметрите от URL-a (query strings) като променливи.</p>
			</li>
		</ol>
  </body>
</html>