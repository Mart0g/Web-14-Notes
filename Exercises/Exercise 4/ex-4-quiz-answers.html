<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz 3 - Answers</title>
  </head>
  <body>
		<h1>Kahoot! Quiz Отговори - Forms</h1>
		<ol>
			<li>
				<h3>Кой е правилният HTML начин за изпращане на форма?</h3>
				<ul>
					<li>&lt;input type="reset"&gt;</li>
          <li>&lt;button type="button"&gt;</li>
          <li><strong><em>&lt;input type="submit"&gt;</em></strong></li>
					<li>&lt;input type="button"&gt;</li>
				</ul>
				<p><strong>Защо?:</strong> "Submit" e типът, който искаме, за да можем всъщност наистина да изпратим данните от формата към сървъра. Останалите се използват с различни цели. &lt;button type="submit"&gt; също е валиден отговор, но в случая е умишлено пропуснат, за да се избегне объркване във въпроса.</p>
			</li>
			<li>
				<h3>Коя стойност на enctype атрибута позволява изпращането на файлове през HTML форма?</h3>
				<ul>
					<li>application/x-www-form-urlencoded</li>
          <li>text/plain</li>
          <li><strong><em>multipart/form-data</em></strong></li>
					<li>Няма нужда от задаване на стойност</li>
				</ul>
				<p><strong>Защо?:</strong> При този тип encoding специалните символи всъщност не се енкодват по какъвто и да е начин. Това съответно ни позволява да качваме и файлове във формата, за да можем да ги изпращаме към сървъра за обработка.</p>
			</li>
			<li>
				<h3>Ако нямаме зададен action в дефиницията на формата, данните ще бъдат изпратени към същия URL.</h3>
				<ul>
					<li><strong><em>Вярно</em></strong></li>
          <li>Грешно</li>
				</ul>
				<p><strong>Защо?:</strong> По спецификация, action обикновено е абсолютен или релативен път (URL) към определена страница. Ако такъв атрибут не е зададен, то за URL се взима този, който води към страницата, съдържаща самата форма - т.е. текущата страница.</p>
			</li>
			<li>
				<h3>Кои са двете глобални променливи, които се използват при форми в PHP?</h3>
				<ul>
					<li>GET, POST</li>
          <li><strong><em>$_GET, $_POST</em></strong></li>
          <li>$GET, $POST</li>
					<li>$__GET, $__POST</li>
				</ul>
				<p><strong>Защо?:</strong> Всички глобални променливи (superglobals) в PHP имат като префикс $_. Съответно същото важи и за GET и SET.</p>
			</li>
			<li>
				<h3>Коя глобална променлива съдържа данните идващи както от GET, така и от POST заявки?</h3>
				<ul>
					<li><strong>$_REQUEST</strong></li>
          <li>$_BOTH</li>
          <li>$_FORM</li>
					<li>$_RESPONSE</li>
				</ul>
				<p><strong>Защо?:</strong> $_REQUEST е това, което се използва в случай че не знаем какъв е методът на заявката, от която сме получили данните. Другите не съществуват.</p>
			</li>
			<li>
				<h3>Кое от следните НЕ е валиден метод за HTTP заявка?</h3>
				<ul>
					<li>PUT</li>
          <li>PATCH</li>
          <li><strong><em>UPDATE</em></strong></li>
					<li>DELETE</li>
				</ul>
				<p><strong>Защо?:</strong> PUT и DELETE са стандартни HTTP методи, докато за обновяване (частични промени) на информация се използва PATCH. UPDATE не съществува.</p>
			</li>
			<li>
				<h3>Данните, съхранявани в $_GET (идващи от GET заявка), са видими за:</h3>
				<ul>
					<li>За никого</li>
          <li>Само за потребителя</li>
          <li><strong><em>За всички</em></strong></li>
					<li>Само за група от потребители</li>
				</ul>
				<p><strong>Защо?:</strong> Това е така, тъй като всички имена на променливи и техните стойности се добавят директно към URL-а след изпращане на формата.</p>
			</li>
			<li>
				<h3>Данните, съхранявани в $_POST (идващи от POST заявка), са видими за:</h3>
				<ul>
					<li>За никого</li>
          <li><strong><em>Само за потребителя</em></strong></li>
          <li>За всички</li>
					<li>Само за група от потребители</li>
				</ul>
				<p><strong>Защо?:</strong> За разлика от GET, тук всички имена на променливи и техните стойности се добавят в тялото (body) на заявката, което е невидимо за всички, освен за потребителя, който изпраща формата.</p>
			</li>
			<li>
				<h3>Какъв ще е резултатът от следната команда в PHP?: echo 1 &lt;=&gt; 1;</h3>
				<ul>
					<li>-1</li>
          <li><strong><em>0</em></strong></li>
          <li>1</li>
					<li>true</li>
				</ul>
				<p><strong>Защо?:</strong> Това е т.нар. spaceship оператор, който прави тройно сравнение между две числа - ако първото е по-малко от второто, резултатът е -1, ако са равни = 0, а ако второто е по-малкото - 1. Най-често се използва за сортиране на масиви.</p>
			</li>
			<li>
				<h3>Следният код: $false = null; echo $false ?? 'false'; ще изведе на екрана 'false'.</h3>
				<ul>
					<li><strong><em>Вярно</em></strong></li>
          <li>Грешно</li>
				</ul>
				<p><strong>Защо?:</strong> Имената и стойностите в случая са сложени за объркване. Всъщност примерът е доста прост, тъй като тук в сила влиза т.нар. null coalesce operator (??). Той изпълнява ролята на вградената в PHP функция isset() и проверява дали стойността на дадена променлива е null. Ако е различна от null, то просто се извежда стойността на променливата. В противен случай се взима дефолтната (или fallback) стойност, която е зададена след дефинирането на оператора.</p>
			</li>
		</ol>
  </body>
</html>